#!/usr/bin/env bash
set -Eeuo pipefail

# ---------- 错误处理 ----------
trap 'echo -e "\n❌ 脚本执行出错（行: $LINENO）。退出。"; exit 1' ERR

# ---------- 配置与默认值 ----------
# 权限级别：不再做口令验证，直接默认 full（可外部覆盖）
export GENSYN_PERMISSION="${GENSYN_PERMISSION:-full}"

# 跳过 /etc/hosts 写入（避免 macOS 要求 sudo 密码）
# 想恢复该功能：执行前设 SKIP_HOSTS_PATCH=0
SKIP_HOSTS_PATCH="${SKIP_HOSTS_PATCH:-1}"

echo "🚀 Starting one-click RL-Swarm environment deployment (no auth)..."

# ---------- 操作系统检测 ----------
OS_TYPE="unknown"
if [[ "$(uname -s)" == "Darwin" ]]; then
  OS_TYPE="macos"
elif [[ -f /etc/os-release ]]; then
  . /etc/os-release
  if [[ "${ID:-}" == "ubuntu" ]]; then
    OS_TYPE="ubuntu"
  fi
fi

if [[ "$OS_TYPE" == "unknown" ]]; then
  echo "❌ 不支持的操作系统。仅支持 macOS 和 Ubuntu。"
  exit 1
fi

# ---------- 公共小函数 ----------
require_cmd() {
  if ! command -v "$1" &>/dev/null; then
    echo "❌ 缺少命令：$1"
    return 1
  fi
}

append_zshrc_once() {
  local LINE="$1"
  local FILE="$HOME/.zshrc"
  grep -Fqx "$LINE" "$FILE" 2>/dev/null || echo "$LINE" >> "$FILE"
}

# ---------- /etc/hosts Patch（默认跳过，防止 sudo 密码提示） ----------
if [[ "$SKIP_HOSTS_PATCH" == "1" ]]; then
  echo "🔧 Skipping /etc/hosts patch (设置 SKIP_HOSTS_PATCH=0 可启用)"
else
  echo "🔧 Checking /etc/hosts configuration..."
  if ! grep -q "raw.githubusercontent.com" /etc/hosts; then
    echo "📝 Writing GitHub accelerated Hosts entries..."
    # 注意：这里需要 sudo，会要求系统密码
    sudo tee -a /etc/hosts > /dev/null <<EOL
199.232.68.133 raw.githubusercontent.com
199.232.68.133 user-images.githubusercontent.com
199.232.68.133 avatars2.githubusercontent.com
199.232.68.133 avatars1.githubusercontent.com
EOL
  else
    echo "✅ Hosts are already configured."
  fi
fi

# ---------- 安装依赖 ----------
if [[ "$OS_TYPE" == "macos" ]]; then
  echo "🍺 Checking Homebrew..."
  if ! command -v brew &>/dev/null; then
    echo "📥 Installing Homebrew..."
    /bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"
  else
    echo "✅ Homebrew 已安装，跳过安装。"
  fi

  # 配置 Brew 环境变量
  BREW_ENV='eval "$(/opt/homebrew/bin/brew shellenv)"'
  append_zshrc_once "$BREW_ENV"
  eval "$(/opt/homebrew/bin/brew shellenv)"

  # 安装依赖（补齐 go 和 jq，便于 p2pd 安装）
  echo "📦 检查并安装 Node.js, Python@3.10, curl, screen, git, yarn, go, jq..."
  deps=(node python3.10 curl screen git yarn go jq)
  brew_names=(node python@3.10 curl screen git yarn go jq)
  for i in "${!deps[@]}"; do
    dep="${deps[$i]}"
    brew_name="${brew_names[$i]}"
    if ! command -v "$dep" &>/dev/null; then
      echo "📥 brew install $brew_name ..."
      # 重试安装，避免偶发网络失败
      until brew install "$brew_name"; do
        echo "⚠️ $brew_name 安装失败，3秒后重试..."
        sleep 3
      done
      echo "✅ $brew_name 安装成功。"
    else
      echo "✅ $dep 已安装，跳过安装。"
    fi
  done

  # 清理旧 python3.12 配置，写入 3.10 alias（与原逻辑保持）
  if grep -q "# Python3.12 Environment Setup" ~/.zshrc 2>/dev/null; then
    echo "🧹 清理旧的 Python3.12 配置..."
    sed -i '' '/# Python3.12 Environment Setup/,/^fi$/d' ~/.zshrc
  fi
  PYTHON_ALIAS="# Python3.10 Environment Setup"
  if ! grep -q "$PYTHON_ALIAS" ~/.zshrc 2>/dev/null; then
    cat << 'EOF' >> ~/.zshrc

# Python3.10 Environment Setup
if [[ $- == *i* ]]; then
  alias python="/opt/homebrew/bin/python3.10"
  alias python3="/opt/homebrew/bin/python3.10"
  alias pip="/opt/homebrew/bin/pip3.10"
  alias pip3="/opt/homebrew/bin/pip3.10"
fi
EOF
  fi
  # 让当前会话尽可能感知最新 PATH
  # shellcheck disable=SC1090
  source ~/.zshrc || true

else
  # ---------- Ubuntu ----------
  echo "📦 检查并安装 Node.js (最新LTS), Python3, curl, screen, git, yarn, jq..."
  if command -v node &>/dev/null; then
    CURRENT_NODE_VERSION="$(node --version 2>/dev/null | sed 's/v//')"
    echo "🔍 当前 Node.js 版本: $CURRENT_NODE_VERSION"
    LATEST_LTS_VERSION="$(curl -fsSL https://nodejs.org/dist/index.json | jq -r '.[0].version' 2>/dev/null | sed 's/v//')"
    echo "🔍 最新 LTS 版本: $LATEST_LTS_VERSION"
    if [[ "${CURRENT_NODE_VERSION:-}" != "${LATEST_LTS_VERSION:-}" && -n "${LATEST_LTS_VERSION:-}" ]]; then
      echo "🔄 更新到最新 LTS 版本..."
      sudo apt remove -y nodejs npm || true
      sudo apt autoremove -y || true
      sudo rm -rf /usr/local/bin/npm /usr/local/bin/node || true
      sudo rm -rf ~/.npm || true
      curl -fsSL https://deb.nodesource.com/setup_lts.x | sudo -E bash -
      sudo apt-get install -y nodejs
      echo "✅ Node.js 已更新至 LTS"
    else
      echo "✅ Node.js 已是最新 LTS 或无法判定，跳过更新"
    fi
  else
    echo "📥 安装 Node.js LTS..."
    curl -fsSL https://deb.nodesource.com/setup_lts.x | sudo -E bash -
    sudo apt-get install -y nodejs
    echo "✅ Node.js 安装完成"
  fi

  sudo apt update
  sudo apt install -y python3 python3-venv python3-pip curl screen git gnupg jq

  # Yarn 安装（官方源优先）
  if curl -fsS https://dl.yarnpkg.com/debian/pubkey.gpg | gpg --dearmor | sudo tee /usr/share/keyrings/yarnkey.gpg >/dev/null \
     && echo "deb [signed-by=/usr/share/keyrings/yarnkey.gpg] https://dl.yarnpkg.com/debian/ stable main" | sudo tee /etc/apt/sources.list.d/yarn.list >/dev/null; then
    sudo apt update && sudo apt install -y yarn
    yarn set version stable || true
    yarn -v || true
  else
    echo "⚠️ 官方源安装 yarn 失败，尝试 npm 安装..."
    if ! command -v npm &>/dev/null; then
      sudo apt install -y npm
    fi
    npm config set registry https://registry.npmmirror.com
    npm install -g yarn
    yarn set version stable || true
    yarn -v || true
  fi

  # 写入 python alias（与原逻辑保持）
  PYTHON_ALIAS="# Python3.12 Environment Setup"
  if ! grep -q "$PYTHON_ALIAS" ~/.bashrc 2>/dev/null; then
    cat << 'EOF' >> ~/.bashrc

# Python3.12 Environment Setup
if [[ $- == *i* ]]; then
  alias python="/usr/bin/python3"
  alias python3="/usr/bin/python3"
  alias pip="/usr/bin/pip3"
  alias pip3="/usr/bin/pip3"
fi
EOF
  fi
  # shellcheck disable=SC1090
  source ~/.bashrc || true
fi

# ---------- 安装/校验 p2pd（Hivemind DHT 需要） ----------
ensure_p2pd() {
  if command -v p2pd &>/dev/null; then
    echo "✅ p2pd 已安装：$(command -v p2pd)"
    return 0
  fi
  echo "📥 安装 p2pd (go-libp2p-daemon)..."
  # 需要 go
  if ! command -v go &>/dev/null; then
    if [[ "$OS_TYPE" == "macos" ]]; then
      echo "📥 通过 Homebrew 安装 go ..."
      brew install go
    else
      echo "📥 通过 apt 安装 golang ..."
      sudo apt update && sudo apt install -y golang-go
    fi
  fi
  mkdir -p "$HOME/.local/bin"
  GOBIN="$HOME/.local/bin" go install github.com/libp2p/go-libp2p-daemon@latest
  # 加 PATH
  if [[ ":$PATH:" != *":$HOME/.local/bin:"* ]]; then
    if [[ "$OS_TYPE" == "macos" ]]; then
      append_zshrc_once 'export PATH="$HOME/.local/bin:$PATH"'
      export PATH="$HOME/.local/bin:$PATH"
    else
      if ! grep -Fqx 'export PATH="$HOME/.local/bin:$PATH"' ~/.bashrc 2>/dev/null; then
        echo 'export PATH="$HOME/.local/bin:$PATH"' >> ~/.bashrc
      fi
      export PATH="$HOME/.local/bin:$PATH"
    fi
  fi
  require_cmd p2pd
  echo "✅ p2pd 安装完成：$(command -v p2pd)"
}
ensure_p2pd

# ---------- 克隆前备份关键文件 ----------
TMP_USER_FILES="$HOME/rl-swarm-user-files"
mkdir -p "$TMP_USER_FILES"

# swarm.pem
if [ -f "$HOME/rl-swarm-0.5.3/swarm.pem" ]; then
  cp "$HOME/rl-swarm-0.5.3/swarm.pem" "$TMP_USER_FILES/swarm.pem" && echo "✅ 已备份 rl-swarm-0.5.3/swarm.pem"
elif [ -f "$HOME/rl-swarm-0.5.3/user/keys/swarm.pem" ]; then
  cp "$HOME/rl-swarm-0.5.3/user/keys/swarm.pem" "$TMP_USER_FILES/swarm.pem" && echo "✅ 已备份 rl-swarm-0.5.3/user/keys/swarm.pem"
elif [ -f "$HOME/rl-swarm-0.5/user/keys/swarm.pem" ]; then
  cp "$HOME/rl-swarm-0.5/user/keys/swarm.pem" "$TMP_USER_FILES/swarm.pem" && echo "✅ 已备份 0.5/user/keys/swarm.pem"
elif [ -f "$HOME/rl-swarm/swarm.pem" ]; then
  cp "$HOME/rl-swarm/swarm.pem" "$TMP_USER_FILES/swarm.pem" && echo "✅ 已备份 rl-swarm/swarm.pem"
else
  echo "⚠️ 未检测到 swarm.pem，如有需要请手动补齐。"
fi

# userApiKey.json
if [ -f "$HOME/rl-swarm-0.5.3/modal-login/temp-data/userApiKey.json" ]; then
  cp "$HOME/rl-swarm-0.5.3/modal-login/temp-data/userApiKey.json" "$TMP_USER_FILES/userApiKey.json" && echo "✅ 已备份 rl-swarm-0.5.3/modal-login/temp-data/userApiKey.json"
elif [ -f "$HOME/rl-swarm-0.5.3/user/modal-login/userApiKey.json" ]; then
  cp "$HOME/rl-swarm-0.5.3/user/modal-login/userApiKey.json" "$TMP_USER_FILES/userApiKey.json" && echo "✅ 已备份 rl-swarm-0.5.3/user/modal-login/userApiKey.json"
elif [ -f "$HOME/rl-swarm-0.5/user/modal-login/userApiKey.json" ]; then
  cp "$HOME/rl-swarm-0.5/user/modal-login/userApiKey.json" "$TMP_USER_FILES/userApiKey.json" && echo "✅ 已备份 0.5/user/modal-login/userApiKey.json"
elif [ -f "$HOME/rl-swarm/modal-login/temp-data/userApiKey.json" ]; then
  cp "$HOME/rl-swarm/modal-login/temp-data/userApiKey.json" "$TMP_USER_FILES/userApiKey.json" && echo "✅ 已备份 rl-swarm/modal-login/temp-data/userApiKey.json"
else
  echo "⚠️ 未检测到 userApiKey.json，如有需要请手动补齐。"
fi

# userData.json
if [ -f "$HOME/rl-swarm-0.5.3/modal-login/temp-data/userData.json" ]; then
  cp "$HOME/rl-swarm-0.5.3/modal-login/temp-data/userData.json" "$TMP_USER_FILES/userData.json" && echo "✅ 已备份 rl-swarm-0.5.3/modal-login/temp-data/userData.json"
elif [ -f "$HOME/rl-swarm-0.5.3/user/modal-login/userData.json" ]; then
  cp "$HOME/rl-swarm-0.5.3/user/modal-login/userData.json" "$TMP_USER_FILES/userData.json" && echo "✅ 已备份 rl-swarm-0.5.3/user/modal-login/userData.json"
elif [ -f "$HOME/rl-swarm-0.5/user/modal-login/userData.json" ]; then
  cp "$HOME/rl-swarm-0.5/user/modal-login/userData.json" "$TMP_USER_FILES/userData.json" && echo "✅ 已备份 0.5/user/modal-login/userData.json"
elif [ -f "$HOME/rl-swarm/modal-login/temp-data/userData.json" ]; then
  cp "$HOME/rl-swarm/modal-login/temp-data/userData.json" "$TMP_USER_FILES/userData.json" && echo "✅ 已备份 rl-swarm/modal-login/temp-data/userData.json"
else
  echo "⚠️ 未检测到 userData.json，如有需要请手动补齐。"
fi

# ---------- Clone Repo ----------
if [[ -d "rl-swarm" ]]; then
  echo "⚠️ 检测到已存在目录 'rl-swarm'。"
  read -rp "是否覆盖（删除后重新克隆）该目录？(y/n): " confirm
  if [[ "$confirm" =~ ^[Yy]$ ]]; then
    echo "🗑️ 正在删除旧目录..."
    rm -rf rl-swarm
    echo "📥 正在克隆 rl-swarm 仓库 (v0.5.8.1 分支)..."
    git clone -b v0.5.8.1 https://github.com/readyName/rl-swarm.git
  else
    echo "❌ 跳过克隆，继续后续流程。"
  fi
else
  echo "📥 正在克隆 rl-swarm 仓库 (v0.5.8.1 分支)..."
  git clone -b v0.5.8.1 https://github.com/readyName/rl-swarm.git
fi

# ---------- 复制临时目录中的 user 关键文件 ----------
KEY_DST="rl-swarm/swarm.pem"
MODAL_DST="rl-swarm/modal-login/temp-data"
mkdir -p "$MODAL_DST"

if [ -f "$TMP_USER_FILES/swarm.pem" ]; then
  cp "$TMP_USER_FILES/swarm.pem" "$KEY_DST" && echo "✅ 恢复 swarm.pem 到新目录" || echo "⚠️ 恢复 swarm.pem 失败"
else
  echo "⚠️ 临时目录缺少 swarm.pem，如有需要请手动补齐。"
fi

for fname in userApiKey.json userData.json; do
  if [ -f "$TMP_USER_FILES/$fname" ]; then
    cp "$TMP_USER_FILES/$fname" "$MODAL_DST/$fname" && echo "✅ 恢复 $fname 到新目录" || echo "⚠️ 恢复 $fname 失败"
  else
    echo "⚠️ 临时目录缺少 $fname，如有需要请手动补齐。"
  fi
done

# ---------- 生成桌面可双击运行的 .command 文件（macOS） ----------
if [[ "$OS_TYPE" == "macos" ]]; then
  CURRENT_USER="$(whoami)"
  PROJECT_DIR="/Users/$CURRENT_USER/rl-swarm"
  DESKTOP_DIR="/Users/$CURRENT_USER/Desktop"
  mkdir -p "$DESKTOP_DIR"

  echo "🔐 权限级别：$GENSYN_PERMISSION"
  if [[ "$GENSYN_PERMISSION" == "full" ]]; then
    TARGETS=(gensyn.sh nexus.sh ritual.sh startAll.sh)
  elif [[ "$GENSYN_PERMISSION" == "gensyn_only" ]]; then
    TARGETS=(gensyn.sh)
  else
    echo "❌ 未知权限级别：$GENSYN_PERMISSION"
    TARGETS=()
  fi

  for script in "${TARGETS[@]}"; do
    cmd_name="${script%.sh}.command"
    cat > "$DESKTOP_DIR/$cmd_name" <<EOF
#!/bin/bash
set -e
trap 'echo -e "\n\033[33m⚠️ 脚本被中断，但终端将继续运行...\033[0m"; exit 0' INT TERM
cd "$PROJECT_DIR" || { echo "❌ 无法进入项目目录"; exit 1; }
echo "🚀 正在执行 $script..."
./$script
echo -e "\n\033[32m✅ $script 执行完成\033[0m"
echo "按任意键关闭此窗口..."
read -n 1 -s
EOF
    chmod +x "$DESKTOP_DIR/$cmd_name"
  done

  # dria.command（仅在 full 权限时生成更合理）
  if [[ "$GENSYN_PERMISSION" == "full" ]]; then
    cat > "$DESKTOP_DIR/dria.command" <<'EOF'
#!/bin/bash
set -e
trap 'echo -e "\n\033[33m⚠️ 脚本被中断，但终端将继续运行...\033[0m"; exit 0' INT TERM
echo "🚀 正在启动 Dria Compute Launcher..."
dkn-compute-launcher start
echo -e "\n\033[32m✅ Dria Compute Launcher 执行完成\033[0m"
echo "按任意键关闭此窗口..."
read -n 1 -s
EOF
    chmod +x "$DESKTOP_DIR/dria.command"
  fi

  # clean_spotlight.command（所有权限级别都生成）
  cat > "$DESKTOP_DIR/clean_spotlight.command" <<EOF
#!/bin/bash
set -e
trap 'echo -e "\n\033[33m⚠️ 脚本被中断，但终端将继续运行...\033[0m"; exit 0' INT TERM
cd "$PROJECT_DIR" || { echo "❌ 无法进入项目目录"; exit 1; }
echo "🚀 正在执行 clean_spotlight.sh..."
./clean_spotlight.sh
echo -e "\n\033[32m✅ clean_spotlight.sh 执行完成\033[0m"
echo "按任意键关闭此窗口..."
read -n 1 -s
EOF
  chmod +x "$DESKTOP_DIR/clean_spotlight.command"

  echo "✅ 已在桌面生成可双击运行的 .command 文件。"
fi

# ---------- Clean Port 3000 ----------
echo "🧹 Cleaning up port 3000..."
if command -v lsof &>/dev/null; then
  pid="$(lsof -ti:3000 || true)"
  if [[ -n "${pid:-}" ]]; then
    kill -9 "$pid" && echo "✅ Killed: $pid" || echo "⚠️ 结束进程失败（PID: $pid）"
  else
    echo "✅ Port 3000 is free."
  fi
else
  echo "⚠️ 未找到 lsof，跳过端口清理。"
fi

# ---------- 进入 rl-swarm 并执行 ----------
cd rl-swarm || { echo "❌ 进入 rl-swarm 目录失败"; exit 1; }
chmod +x gensyn.sh
./gensyn.sh
